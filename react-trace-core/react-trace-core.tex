\documentclass{article}
\usepackage[utf8]{inputenc}

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage{parskip}
\usepackage{mathtools}

\newcommand{\num}[1]{\overline{#1}}
\newcommand{\mf}[1]{\mathsf{#1}}
\newcommand{\mc}[1]{\mathcal{#1}}
\newcommand{\mb}[1]{\mathbf{#1}}
\newcommand{\tf}[1]{\textsf{#1}}
\newcommand{\ts}[1]{\textsc{#1}}
\newcommand{\pp}{+\!\!\!+\: }
\newcommand{\semi}{\,;\,}

\newcommand{\pair}[2]{\langle #1, #2 \rangle}
\newcommand{\four}[4]{\langle #1, #2, #3, #4 \rangle}
\newcommand{\map}[2]{[\num{#1 \mapsto #2}]}
\newcommand{\smallstep}[2]{\mapsto^{#1}_{#2}}
\newcommand{\multistep}[2]{\xmapsto{*}^{#1}_{#2}}
\newcommand{\vdashd}{\vdash_\Delta}
\newcommand{\Vdashd}{\Vdash_\Delta}
\newcommand{\prog}{\mf{Prog}}

\newcommand{\one}{\mb{1}}
\newcommand{\elet}[3]{\mf{let}\ #1 = #2\ \mf{in}\ #3}
\newcommand{\erun}[1]{\mf{run}\ #1}
\newcommand{\eif}[3]{\mf{if}\ #1\ \mf{then}\ #2\ \mf{else}\ #3}
\newcommand{\eret}[1]{\mf{return}\ #1}
\newcommand{\estate}[4]{\mf{let}\ (#1, #1_{\mf{set}}) = \mf{useState}^{#2}(#3)\ \mf{in}\ #4}
\newcommand{\vset}[2]{\mf{set}@^{#1}_{#2}}


\title{React-tRace Core}
\author{Toby Ueno}

\begin{document}

\maketitle

Syntax:
\begin{align*}
\text{Value } v &::= x \mid \mf{true} \mid \mf{false} \mid n \mid s \mid \lambda x: \tau.e \mid \mc{C}
\mid \mf{text}\ v \mid \mf{tag}(v, \num{v}, \num{v})\\
&\mid \mf{attr}(v, v) \mid \mf{onClick}\ v\\
\text{Expression } e &::= \eret{v} \mid \elet{x}{e}{e} \mid v\ v \mid v \oplus v \mid \eif{v}{e}{e}\\
\text{Top-level expr }\hat{e} &::= e \mid \estate{x}{\ell}{v}{\hat{e}} \mid \elet{x}{e}{\hat{e}}\\
\text{Program } P &::= e \mid \elet{x}{e}{P} \mid \elet{\mc{C}(x : \tau)}{\hat{e}}{P}\\
\text{Type } \tau &::= \one \mid \mf{bool} \mid \mf{int} \mid \tau \xrightarrow{E} \tau
\mid \mf{view} \mid \mf{component}\ \tau \mid \mf{setter}\ \tau \mid \mf{attr}\\
\text{Effect } E &::= \epsilon \mid \mf{Mut}
\end{align*}

Internal representations:
\begin{align*}
\text{Component declarations }\Delta &::= \map{\mc{C}}{\tau}\\
\text{Phase }\phi &::= \mf{Init} \mid \mf{Succ}\\
\text{Tree }t &::= \mf{lit}\ v \mid \mf{node}(id, v, \num{v}, \num{t}) \mid p\\
\text{Realized component}\pi &::= \{\mf{spec}: \pair{\mc{C}}{v}, \mf{st}: \map{\ell}{v}, \mf{child}: t\}\\
\text{Tree memory }m &::= \map{p}{\pi}\\
\text{Component definitions }\mc{D} &::= \map{\mc{C}}{x.\hat{e}}\\
\text{Mode }\mu &::= \mf{start}(P) \mid \mf{idle} \mid \mf{rerender}(m)
\end{align*}

Effect unification:
\[
E_1 \circ E_2 = \begin{cases}
    \epsilon & E_1 = E_2 = \epsilon\\
    \mf{Mut} & \text{otherwise}
\end{cases}
\]

\pagebreak

All typing judgments are relative to a fixed $\Delta$,
which can be determined prior to typechecking by iterating through
all components in the program and noting their arguments' type annotations.


Value typing: $\Gamma \vdashd v: \tau$

\begin{mathpar}
\inferrule*[right=TVal-Var] {
  x : \tau \in \Gamma
} {
  \Gamma \vdashd x: \tau
}
\and
\inferrule*[right=TVal-Unit] { } {
  \Gamma \vdashd () : \one
}
\and
\inferrule*[right=TVal-True] { } {
  \Gamma \vdashd \mf{true} : \mf{bool}
}
\and
\inferrule*[right=TVal-False] { } {
  \Gamma \vdashd \mf{false} : \mf{bool}
}
\and
\inferrule*[right=TVal-Int] { } {
  \Gamma \vdashd n : \mf{int}
}
\and
\inferrule*[right=TVal-Str] { } {
  \Gamma \vdashd s : \mf{string}
}
\and
\inferrule*[right=TVal-Lam] {
  \Gamma, x: \tau_1 \vdashd e : \tau_2 \mid E
} {
  \Gamma \vdashd \lambda x: \tau_1.e: \tau_1 \xrightarrow{E} \tau_2
}
\and
\inferrule*[right=TVal-Comp] {
  \mc{C}: \mf{component}\ \tau \in \Delta
} {
  \Gamma \vdashd \mc{C} : \mf{component}\ \tau
}
\and
\inferrule*[right=TVal-Text] {
  \Gamma \vdashd v: \tau
  \and
  \tau \in \{\mf{bool}, \mf{int}, \mf{string}\}
} {
  \Gamma \vdashd \mf{text}\ v: \mf{view}
}
\and
\inferrule*[right=TVal-Tag] {
  \Gamma \vdashd v: \mf{string}
  \and
  (\forall i)\ \Gamma \vdashd v_i: \mf{attr}
  \and
  (\forall j)\ \Gamma \vdashd v_j: \mf{view}
} {
  \Gamma \vdashd \mf{tag}(v, \num{v_i}, \num{v_j}): \mf{view}
}
\and
\inferrule*[right=TVal-Attr] {
  \Gamma \vdashd v_k: \mf{string}
  \and
  \Gamma \vdashd v_v: \mf{string}
} {
  \Gamma \vdashd \mf{attr}(v_k, v_v): \mf{attr}
}
\and
\inferrule*[right=TVal-OnClick] {
  \Gamma \vdashd v: \one \xrightarrow{E} \one
} {
  \Gamma \vdashd \mf{onClick}\ v: \mf{attr}
}
\end{mathpar}

\pagebreak

Base expression typing: $\Gamma \vdashd e : x \mid E$

\begin{mathpar}
\inferrule*[right=TExp-Ret] {
  \Gamma \vdashd v: \tau
} {
  \Gamma \vdashd \eret{v}: \tau \mid \epsilon
}
\and
\inferrule*[right=TExp-Let] {
  \Gamma \vdashd e_1 : \tau_1 \mid E_1
  \and
  \Gamma, x: \tau_1 \vdashd e_2 : \tau_2 \mid E_2
} {
  \Gamma \vdashd \elet{x}{e_1}{e_2}: \tau_2 \mid E_1 \circ E_2
}
\and
\inferrule*[right=TExp-AppFun] {
  \Gamma \vdashd v_1 : \tau_1 \xrightarrow{E} \tau_2
  \and
  \Gamma \vdashd v_2 : \tau_1
} {
  \Gamma \vdashd v_1\ v_2: \tau_2 \mid E
}
\and
\inferrule*[right=TExp-AppComp] {
  \Gamma \vdashd v_1 : \mf{component}\ \tau
  \and
  \Gamma \vdashd v_2 : \tau
} {
  \Gamma \vdashd v_1\ v_2: \mf{view} \mid \epsilon
}
\and
\inferrule*[right=TExp-AppSet] {
  \Gamma \vdashd v_1 : \mf{setter}\ \tau
  \and
  \Gamma \vdashd v_2 : \tau
} {
  \Gamma \vdashd v_1\ v_2: \one \mid \mf{Mut}
}
\and
\inferrule*[right=TExp-Bop] {
  \Gamma \vdashd v_1 : \mf{int}
  \and
  \Gamma \vdashd v_2 : \mf{int}
  \and
  \oplus : \mathbb{Z} \times \mathbb{Z} \rightarrow \mathbb{Z}
} {
  \Gamma \vdashd v_1 \oplus v_2 : \mf{int}
}
\and
\inferrule*[right=TExp-If] {
  \Gamma \vdashd v : \mf{bool}
  \and
  \Gamma \vdashd e_1 : \tau \mid E_1
  \and
  \Gamma \vdashd e_2 : \tau \mid E_2
} {
  \Gamma \vdashd \eif{v}{e_1}{e_2} : \tau \mid E_1 \circ E_2
}
\end{mathpar}

\pagebreak

Top-level expression typing: $\Gamma \Vdashd \hat{e}: \tau$

\begin{mathpar}
\inferrule*[right=THat-Lift] {
  \Gamma \vdashd e: \tau \mid \epsilon
} {
  \Gamma \Vdashd \hat{e} : \tau
}
\and
\inferrule*[right=THat-Let] {
  \Gamma \vdashd e: \tau_1 \mid \epsilon
  \and
  \Gamma, x: \tau_1 \Vdashd \hat{e}: \tau_2
} {
  \Gamma \Vdashd \elet{x}{e}{\hat{e}}: \tau_2
}
\and
\inferrule*[right=THat-State] {
  \Gamma \vdashd v: \tau_1
  \and
  \Gamma, x: \tau_1, x_\mf{set}: \tau_1 \xrightarrow{\mf{Set}} \one \Vdashd \hat{e} : \tau_2
} {
  \Gamma \Vdashd \estate{x}{\ell}{v}{\hat{e}} : \tau_2
}
\end{mathpar}

Program judgment: $\Gamma \vdashd P$

\begin{mathpar}
\inferrule*[right=TProg-Let] {
  \Gamma \vdashd e: \tau \mid \epsilon
  \and 
  \Gamma, x: \tau \vdashd P
} {
  \Gamma \vdashd \elet{x}{e}{P}
}
\and
\inferrule*[right=TProg-Comp] {
  \Gamma, x: \tau \Vdashd \hat{e}: \mf{view}
  \and 
  \Gamma \vdashd P
} {
  \Gamma \vdashd \elet{\mc{C}(x: \tau)}{\hat{e}}{P}
}
\and
\inferrule*[right=TProg-Run] {
  \Gamma \vdashd {e}: \mf{view} \mid \epsilon
} {
  \Gamma \vdashd \erun{e}
}
\end{mathpar}

\pagebreak

Throughout the semantics, we use the notation $m' = m \mid x = v$
to concisely denote nested map/record updates.
The above should be read as ``$m'$ equals $m$ with field $x$ set to $v$''.
For instance, $m' = m \mid m[p].st[\ell] = v$ updates the
state field of $m$ at path $p$ and location $\ell$ to value $v$
and names the result $m'$.

Pure expression semantics: $m \semi e \mapsto e' \semi m'$

\begin{mathpar}
\inferrule*[right=E-LetPure] {
  m \semi e_1 \mapsto e_1' \semi m'
} {
  m \semi \elet{x}{e_1}{e_2} \mapsto \elet{x}{e_1'}{e_2} \semi m'
}
\end{mathpar}
\begin{align*}
m \semi \elet{x}{\eret{v}}{e} &\mapsto e[v/x] \semi m
&&\textsc{E-Ret}\\
m \semi (\lambda x.e) v &\mapsto e[v/x] \semi m
&&\textsc{E-AppFun}\\
m \semi \mc{C}\ v &\mapsto \pair{\mc{C}}{v} \semi m
&&\textsc{E-AppComp}\\
m \semi \vset{\ell}{p}\ v &\mapsto () \semi m'
&&\textsc{E-AppSet}\\
(m' &= m \mid m[p].st[\ell] = v)\\
m \semi n_1 \oplus n_2 
&\mapsto \eret{\llbracket n_1 \oplus n_2 \rrbracket} \semi m
&&\textsc{E-Bop}\\
m \semi \eif{\mf{true}}{e_1}{e_2} &\mapsto e_1 \semi m
&&\textsc{E-IfTrue}\\
m \semi \eif{\mf{false}}{e_1}{e_2} &\mapsto e_2 \semi m
&&\textsc{E-IfFalse}
\end{align*}

Top-level expression semantics: $m \semi \hat{e} \smallstep{\phi}{p} \hat{e}' \semi m'$

\begin{mathpar}
\inferrule*[right=E-Lift] {
  m \semi e \mapsto e' \semi m'
} {
  m \semi e \smallstep{\phi}{p} e' \semi m'
}
\and
\inferrule*[right=E-LetTop] {
  m \semi e \mapsto e' \semi m'
} {
  m \semi \elet{x}{e}{\hat{e}} \smallstep{\phi}{p} \elet{x}{e'}{\hat{e}} \semi m'
}
\end{mathpar}
\begin{align*}
m \semi \elet{x}{\eret{v}}{\hat{e}} &\smallstep{\phi}{p} \hat{e}[v/x] \semi m
&&\textsc{E-RetTop}\\
m \semi \estate{x}{\ell}{v}{\hat{e}}
&\smallstep{\mf{Init}}{p}
\hat{e}[v/x, \vset{\ell}{p}/x_\mf{set}] \semi m'
&&\textsc{E-StInit}\\
(m' &= m \mid m[p].\mf{st}[\ell] = v)\\
m \semi \estate{x}{\ell}{v}{\hat{e}}
&\smallstep{\mf{Succ}}{p}
\hat{e}[v'/x, \vset{\ell}{p}/x_\mf{set}] \semi m
&&\textsc{E-StSucc}\\
(v' &= m[p].\mf{st}[\ell])
\end{align*}

\pagebreak

Program expression semantics: $m \semi \mc{D} \semi P \Mapsto P' \semi \mc{D}' \semi m'$

\begin{mathpar}
\inferrule*[right=E-Run] {
  m \semi e \mapsto e' \semi m'
} {
  m \semi \mc{D} \semi \erun{e} \Mapsto \erun{e'} \semi \mc{D} \semi m'
}
\and
\inferrule*[right=E-LetProg] {
  m \semi e \mapsto e' \semi m'
} {
  m \semi \mc{D} \semi \elet{x}{e}{P} 
  \Mapsto
  \elet{x}{e'}{P} \semi \mc{D} \semi m'
}
\end{mathpar}
\begin{align*}
m \semi \mc{D} \semi \elet{x}{\eret{v}}{P}
&\Mapsto
P[v/x] \semi \mc{D} \semi m
&&\textsc{E-RetProg}\\
m \semi \mc{D} \semi \elet{\mc{C}(x)}{\hat{e}}{P}
&\Mapsto
P \semi \mc{D}[\mc{C} \mapsto x.\hat{e}] \semi m
&&\textsc{E-CompDef}
\end{align*}

Node initialization: $\mc{D} \semi m \vdash \mf{init}(v) = \pair{t}{m'}$

\begin{mathpar}
\inferrule*[right=Init-Lit] { } {
  \mc{D} \semi m \vdash \mf{init}(\mf{text}\ v) = \pair{\mf{lit}\ v}{m}
}
\and
\inferrule*[right=Init-Node] {
  id\ \mf{fresh}
  \and
  (\forall j)\ \mc{D} \semi m_j \vdash \mf{init}(v_j) = \pair{t_j}{m_{j+1}}
} {
  \mc{D} \semi m_0 \vdash \mf{init}(\mf{tag}(v, \num{v_i}, \num{v_j}_{j=0}^{n-1})) 
  = \pair{\mf{node}(id, v, \num{v_i}, \num{t_j})}{m_n}
}
\and
\inferrule*[right=Init-Comp] {
  m_0 \vdash p\ \mf{fresh}
  \and
  \mc{D}[\mc{C}] = x.\hat{e}\\
  m_0[p \mapsto \{\mf{spec}: \pair{\mc{C}}{v}, \mf{st}: \emptyset, \mf{child}: \emptyset\}]
  \semi \hat{e}[v/x] \multistep{\mf{Init}}{p} \eret{v'} \semi m_1\\
  \mc{D} \semi m_1 \vdash \mf{init}(v') = \pair{t}{m_2}
} {
  \mc{D} \semi m_0 \vdash \mf{init}(\pair{\mc{C}}{v}) 
  = \pair{p}{m_2 \mid m_2[p].\mf{child} = t}
}
\end{mathpar}

(Na√Øve) re-render: $\mc{D} \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, t) = m$

\begin{mathpar}
\inferrule*[right=Check-Lit] { } {
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, \mf{lit}\ v) 
  = m_\mf{new}
}
\and
\inferrule*[right=Check-Node] {
  (0 \leq j < n) \quad
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_j, t_j) = \pair{t_j'}{m_{j+1}}
} {
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_0, \mf{node}(id, v, \num{v_i}, \num{t_j})) = m_n
}
\and
\inferrule*[right=Check-PathConst] {
  m_\mf{old}[p].\mf{st} = m_\mf{new}[p].\mf{st}\\
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, m_\mf{old}[p].child) 
  = m
} {
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, p) 
  = m
}
\and
\inferrule*[right=Check-PathDiff] { 
  m_\mf{old}[p].\mf{st} \neq m_\mf{new}[p].\mf{st}
  \\
  m'[p].\mf{spec} = \pair{\mc{C}}{v}
  \and
  \mc{D}[\mc{C}] = x.\hat{e}
  \\
  m_\mf{new} \semi \hat{e}[v/x] \multistep{\mf{Succ}}{p} \eret{v'} \semi m
  \\
  \mc{D} \semi m \vdash \mf{init}(v') = \pair{t}{m'}
} {
  \mc{D} \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, p)
   = \pair{p}{m' \mid m[p].\mf{child}=t}
}
\end{mathpar}

\pagebreak

Event loop semantics: $\four{\mc{D}}{m}{t}{\mu} \hookrightarrow \four{\mc{D}'}{m'}{t}{\mu'}$

\begin{mathpar}
\inferrule*[right=Loop-Start] {
  \cdot \semi \cdot \semi P \Mapsto^* \mf{run}(\eret{v}) \semi \mc{D} \semi m
  \\
  \mc{D} \semi m \vdash \mf{init}(v) = \pair{t}{m'}
} {
  \four{\cdot}{\cdot}{\cdot}{\mf{start}(P)} 
  \hookrightarrow
  \four{\mc{D}}{m'}{t}{\mf{idle}}
}
\and
\inferrule*[right=Loop-Event] {
  \exists\; id
  \and
  m \vdash \mf{handlers}(t, id) = \num{v_i}
  \\
  (0 \leq i < n)\quad
  m_i \semi v_i\ () \mapsto^* \eret{()} \semi m_{i+1}
} {
  \four{\mc{D}}{m_0}{t}{\mf{idle}} \hookrightarrow \four{\mc{D}}{m}{t}{\mf{rerender}(m_n)}
}
\and
\inferrule*[right=Loop-Rerender] {
  D \semi m_\mf{old} \vdash \mf{check}(m_\mf{new}, t) = m
} {
  \four{\mc{D}}{m_\mf{old}}{t}{\mf{rerender}(m_\mf{new})}
  \hookrightarrow
  \four{\mc{D}}{m}{t}{\mf{idle}}
}
\end{mathpar}

Handler search: $m \vdash \mf{handlers}(t, id) = \num{v}$

\begin{mathpar}
\inferrule*[right=Handlers-Lit] { } {
  m \vdash \mf{handlers}(\mf{lit}\ v, id) = \{\}
}
\and
\inferrule*[right=Handlers-Comp] {
  m \vdash \mf{handlers}(m[p].\mf{child}, id) = \num{v}
} {
  m \vdash \mf{handlers}(p, id) = \num{v}
}
\and
\inferrule*[right=Handlers-Tgt] { } {
  m \vdash \mf{handlers}(\mf{node}(id, v, \num{v_i}, \num{v_j}), id)
  = \{v_h \mid \mf{onClick}\ v_h \in \num{v_i}\}
}
\and
\inferrule*[right=Handlers-Node] {
  id \neq id'
  \and
  (\forall j)\ 
  m \vdash \mf{handlers}(v_j, id) = h_j
} {
  m \vdash \mf{handlers}(\mf{node}(id', v, \num{v_i}, \num{v_j}), id)
  = \bigcup_{\forall j} h_j
}
\end{mathpar}

\end{document}